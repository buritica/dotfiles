# `e` with no arguments opens the current directory in VSCode, otherwise
# opens the given location
function e() {
	if [ $# -eq 0 ]; then
		code .;
	else
		code "$@";
	fi;
}

# `s` with no arguments cds into ~/src directory, otherwise opens the given subdir
function s() {
	if [ $# -eq 0 ]; then
		cd ~/src;
	else
		cd ~/src/"$@";
	fi;
}

# `my` with no arguments cds into ~/.my directory, otherwise opens the given subdir
function my() {
	if [ $# -eq 0 ]; then
		cd ~/.my;
	else
		cd ~/.my/"$@";
	fi;
}

# `dr` with no arguments cds into iCloud Drive  directory, otherwise opens the given subdir
function dr() {
	if [ $# -eq 0 ]; then
		cd ~/Library/Mobile\ Documents/com~apple~CloudDocs;
	else
		cd ~/Library/Mobile\ Documents/com~apple~CloudDocs/"$@";
	fi;
}

# empty commit as todo
todo() {
  git commit --allow-empty -m "TODO: $*"
}

# turn movie into gif
# thanx SlexAxton https://gist.github.com/SlexAxton/4989674
gifify() {
  if [[ -n "$1" ]]; then
    if [[ $2 == '--good' ]]; then
      ffmpeg -i $1 -r 10 -vcodec png out-static-%05d.png
      time convert -verbose +dither -layers Optimize -resize 600x600\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > $1.gif
      rm out-static*.png
    else
      ffmpeg -i $1 -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > $1.gif
    fi
  else
    echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$_";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh;
  else
    local arg=-sh;
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@";
  else
    du $arg .[^.]* *;
  fi;
}

# Use Gitâ€™s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
  function diff() {
    git diff --no-index --color-words "$@";
  }
fi;

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}";
  sleep 1 && open "http://localhost:${port}/" &
  # Use Python 3's http.server module
  python3 -m http.server "$port";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
  if [ -t 0 ]; then # argument
    python3 -m json.tool <<< "$*" | pygmentize -l javascript;
  else # pipe
    python3 -m json.tool | pygmentize -l javascript;
  fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
  if [ $# -eq 0 ]; then
    open .;
  else
    open "$@";
  fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}


# Safer alternative to fixit - amend and push without force
# Uses --force-with-lease which is safer than --force
fixup() {
    git add . && git commit --amend --no-edit && git push --force-with-lease
}

# contains(string, substring)
#
# Returns 0 if the specified string contains the specified substring,
# otherwise returns 1.
contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# Show what's installed but not in Brewfile
brew-installed-only() {
    local brewfile="${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"

    # If in chezmoi source directory, use the template file
    if [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        brewfile="dot_my/dot_Brewfile.tmpl"
    fi

    echo "ðŸ“¦ Formulas installed but not in Brewfile:"
    comm -13 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort) | \
        grep -v "^$(brew deps --installed --formula | sort -u | paste -sd "|" -)$" || echo "  (none)"

    echo ""
    echo "ðŸ–¥ï¸  Casks installed but not in Brewfile:"
    comm -13 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort) || echo "  (none)"
}

# Show what's in Brewfile but not installed
brew-missing() {
    local brewfile="${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"

    # If in chezmoi source directory, use the template file
    if [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        brewfile="dot_my/dot_Brewfile.tmpl"
    fi

    echo "ðŸ“¦ Formulas in Brewfile but not installed:"
    comm -23 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort) || echo "  (none)"

    echo ""
    echo "ðŸ–¥ï¸  Casks in Brewfile but not installed:"
    comm -23 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort) || echo "  (none)"
}

# Show diff between Brewfile and installed packages
brew-diff() {
    echo "=== Brewfile vs Installed Packages ==="
    echo ""
    brew-installed-only
    echo ""
    brew-missing
}

# Interactively sync Brewfile with installed packages
brew-sync() {
    local brewfile="${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"
    local temp_brewfile="/tmp/Brewfile.new"

    # If in chezmoi source directory, use the template file
    if [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        brewfile="dot_my/dot_Brewfile.tmpl"
    fi

    if [[ ! -f "$brewfile" ]]; then
        echo "âŒ Brewfile not found at $brewfile"
        return 1
    fi

    echo "ðŸ” Analyzing installed packages..."
    echo ""

    # Generate current Brewfile
    brew bundle dump --file="$temp_brewfile" --force

    # Get lists of differences
    local new_formulas=($(comm -13 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(grep '^brew "' "$temp_brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort)))

    local new_casks=($(comm -13 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(grep '^cask "' "$temp_brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort)))

    local removed_formulas=($(comm -23 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort)))

    local removed_casks=($(comm -23 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort)))

    local changes_made=false

    # Show new formulas
    if [[ ${#new_formulas[@]} -gt 0 ]]; then
        echo "âž• New formulas installed (not in Brewfile):"
        for formula in "${new_formulas[@]}"; do
            echo "   - $formula"
        done
        echo ""
        read -p "Add all new formulas to Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        else
            echo "â„¹ï¸  Skipping formulas. Run 'brew-sync' again to reconsider."
        fi
    fi

    # Show new casks
    if [[ ${#new_casks[@]} -gt 0 ]]; then
        echo "âž• New casks installed (not in Brewfile):"
        for cask in "${new_casks[@]}"; do
            echo "   - $cask"
        done
        echo ""
        read -p "Add all new casks to Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        fi
    fi

    # Show removed items
    if [[ ${#removed_formulas[@]} -gt 0 ]] || [[ ${#removed_casks[@]} -gt 0 ]]; then
        if [[ ${#removed_formulas[@]} -gt 0 ]]; then
            echo "âž– Formulas in Brewfile but not installed:"
            for formula in "${removed_formulas[@]}"; do
                echo "   - $formula"
            done
        fi
        if [[ ${#removed_casks[@]} -gt 0 ]]; then
            echo "âž– Casks in Brewfile but not installed:"
            for cask in "${removed_casks[@]}"; do
                echo "   - $cask"
            done
        fi
        echo ""
        read -p "Remove uninstalled items from Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        fi
    fi

    if [[ "$changes_made" == true ]]; then
        echo ""
        echo "ðŸ“ Updating Brewfile..."
        cp "$temp_brewfile" "$brewfile"

        if command -v chezmoi &>/dev/null; then
            echo "ðŸ”„ Syncing with chezmoi..."
            chezmoi add "$brewfile"
            echo "âœ… Brewfile updated and added to chezmoi!"
        else
            echo "âœ… Brewfile updated!"
        fi
    else
        echo "âœ… No changes made to Brewfile"
    fi

    rm -f "$temp_brewfile"
}

# Safe process grep with modern tool
pg() {
    if [ $# -eq 0 ]; then
        echo "Usage: pg <search_term>"
        return 1
    fi
    procs --or "${@}" 2>/dev/null || ps aux | grep -v grep | grep -i --color=auto "${@}"
}

# Safe npm clean with confirmation
npm-clean() {
    echo "This will delete node_modules and reinstall. Continue? [y/N]"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        rm -rf ./node_modules && npm install
    else
        echo "Cancelled"
    fi
}

# fzf-powered directory navigation
fcd() {
    if ! command -v fd &>/dev/null || ! command -v fzf &>/dev/null || ! command -v eza &>/dev/null; then
        echo "Error: fcd requires fd, fzf, and eza to be installed"
        return 1
    fi
    local dir
    dir=$(fd --type d --hidden --follow --exclude .git | fzf --preview 'eza --tree --level=2 --icons {}') && cd "$dir" || return
}

# fzf-powered file editing
fe() {
    if ! command -v fzf &>/dev/null || ! command -v bat &>/dev/null || ! command -v code &>/dev/null; then
        echo "Error: fe requires fzf, bat, and code to be installed"
        return 1
    fi
    local files
    files=$(fzf --multi --preview 'bat --color=always --style=numbers --line-range=:500 {}') && code "$files"
}

# fzf-powered git branch switching
fbr() {
    local branch
    branch=$(git branch --all | grep -v HEAD | sed 's/remotes\/origin\///' | sort -u | fzf --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" {}') && git checkout "$(echo "$branch" | sed 's/^[ *]*//')"
}

# fzf-powered git log viewer
fshow() {
    git log --graph --color=always \
        --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
    fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
        --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# fzf-powered ripgrep search
frg() {
    if [ $# -eq 0 ]; then
        echo "Usage: frg <search_term>"
        return 1
    fi

    rg --color=always --line-number --no-heading --smart-case "${*:-}" |
      fzf --ansi \
          --color "hl:-1:underline,hl+:-1:underline:reverse" \
          --delimiter : \
          --preview 'bat --color=always {1} --highlight-line {2}' \
          --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \
          --bind 'enter:become(code {1}:{2})'
}

# GitHub CLI - PR viewer
ghpr() {
    if ! command -v gh &>/dev/null || ! command -v fzf &>/dev/null; then
        echo "Error: ghpr requires gh and fzf to be installed"
        return 1
    fi
    gh pr list | fzf --preview 'gh pr view {1}' --preview-window=right:60% | awk '{print $1}' | xargs gh pr view --web
}

# GitHub CLI - Issue viewer
ghissue() {
    if ! command -v gh &>/dev/null || ! command -v fzf &>/dev/null; then
        echo "Error: ghissue requires gh and fzf to be installed"
        return 1
    fi
    gh issue list | fzf --preview 'gh issue view {1}' --preview-window=right:60% | awk '{print $1}' | xargs gh issue view --web
}

# Export Brewfile from current installation
brew-export() {
    local brewfile="${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"

    if [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        brewfile="dot_my/dot_Brewfile.tmpl"
    fi

    echo "ðŸ“ Generating Brewfile from current installation..."
    brew bundle dump --file="$brewfile" --force

    if command -v chezmoi &>/dev/null && [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        echo "ðŸ”„ Syncing with chezmoi..."
        chezmoi add "$brewfile"
    fi

    echo "âœ… Brewfile exported to $brewfile"
}

# Detect orphaned packages
brew-orphans() {
    echo "ðŸ” Checking for orphaned packages..."

    # Get all leaves (top-level packages)
    local leaves=$(brew leaves)

    # Get all dependencies of leaves in one call
    local all_deps=$(brew deps --installed --for-each $leaves 2>/dev/null | awk '{print $NF}')

    # Get all installed packages
    local installed=$(brew list --formula)

    # Find packages that are neither leaves nor dependencies
    for package in $installed; do
        if ! echo "$leaves" | grep -q "^${package}$" && ! echo "$all_deps" | grep -q "^${package}$"; then
            echo "  $package"
        fi
    done
}

# Clean up brew cache
brew-cleanup() {
    echo "ðŸ§¹ Cleaning up Homebrew..."
    brew cleanup --prune=all
    brew autoremove
    echo "âœ… Cleanup complete"
}
