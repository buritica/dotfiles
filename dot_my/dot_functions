# `e` with no arguments opens the current directory in VSCode, otherwise
# opens the given location
function e() {
	if [ $# -eq 0 ]; then
		code .;
	else
		code "$@";
	fi;
}

# `s` with no arguments cds into ~/src directory, otherwise opens the given subdir
function s() {
	if [ $# -eq 0 ]; then
		cd ~/src;
	else
		cd ~/src/"$@";
	fi;
}

# `my` with no arguments cds into ~/.my directory, otherwise opens the given subdir
function my() {
	if [ $# -eq 0 ]; then
		cd ~/.my;
	else
		cd ~/.my/"$@";
	fi;
}

# `dr` with no arguments cds into iCloud Drive  directory, otherwise opens the given subdir
function dr() {
	if [ $# -eq 0 ]; then
		cd ~/Library/Mobile\ Documents/com~apple~CloudDocs;
	else
		cd ~/Library/Mobile\ Documents/com~apple~CloudDocs/"$@";
	fi;
}

# empty commit as todo
todo() {
  if ! git rev-parse --git-dir &>/dev/null; then
    echo "‚ùå Not a git repository"
    return 1
  fi
  git commit --allow-empty -m "TODO: $*"
}

# turn movie into gif
# thanx SlexAxton https://gist.github.com/SlexAxton/4989674
gifify() {
  if [[ -n "$1" ]]; then
    if [[ $2 == '--good' ]]; then
      ffmpeg -i "$1" -r 10 -vcodec png out-static-%05d.png
      time convert -verbose +dither -layers Optimize -resize 600x600\> out-static-*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > "$1.gif"
      rm out-static-*.png
    else
      ffmpeg -i "$1" -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > "$1.gif"
    fi
  else
    echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$_";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Determine size of a file or total size of a directory
function fs() {
  if command -v dust &>/dev/null; then
    dust -d 1 -r "$@"
  else
    # Fallback to traditional du
    if du -b /dev/null > /dev/null 2>&1; then
      local arg=-sbh;
    else
      local arg=-sh;
    fi
    if [[ -n "$@" ]]; then
      du "$arg" -- "$@";
    else
      du "$arg" .[^.]* *;
    fi
  fi
}

# Dust wrapper for common patterns
disk() {
  if ! command -v dust &>/dev/null; then
    echo "‚ùå disk requires dust: brew install dust"
    return 1
  fi
  dust -d "${1:-2}" -r "${2:-.}"
}

# Use Git's colored diff when available, with delta enhancement
if command -v git &>/dev/null; then
  function diff() {
    if command -v delta &>/dev/null; then
      git diff --no-index --color-words "$@" | delta
    else
      git diff --no-index --color-words "$@"
    fi
  }
fi

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}";
  sleep 1 && open "http://localhost:${port}/" &
  # Use Python 3's http.server module
  python3 -m http.server "$port";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
  if [ -t 0 ]; then # argument
    python3 -m json.tool <<< "$*" | pygmentize -l javascript;
  else # pipe
    python3 -m json.tool | pygmentize -l javascript;
  fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
  if [ $# -eq 0 ]; then
    open .;
  else
    open "$@";
  fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
  eza --tree --git-ignore --icons --level="${1:-3}" "${@:2}" | less -FRN;
}

# Tree variants using eza
tree() { eza --tree --git-ignore --icons --level="${1:-3}"; }
tree-all() { eza --tree --all --icons --level="${1:-2}"; }  # Default depth 2 (--all is verbose)

# Safer alternative to fixit - amend and push without force
# Uses --force-with-lease which is safer than --force
fixup() {
  if ! git rev-parse --git-dir &>/dev/null; then
    echo "‚ùå Not a git repository"
    return 1
  fi
  git add . && git commit --amend --no-edit && git push --force-with-lease
}

# contains(string, substring)
#
# Returns 0 if the specified string contains the specified substring,
# otherwise returns 1.
contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"; then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# Show current machine profile information
machine-info() {
    echo "Hostname: $(hostname -s)"
    chezmoi data | grep -A 4 'machine:' | sed 's/^/  /'
}

# List all configured machine profiles
machine-list() {
    echo "Configured machine profiles:"
    echo "  üè° crowntail (home)    - Personal home workstation"
    echo "  üíº deltatail (work)    - Work laptop"
    echo "  üé• halfmoon (media)    - Video editing station"
    echo ""
    echo "Current machine:"
    machine-info
}

# Helper: Get the Brewfile path (always uses deployed version)
_get_brewfile_path() {
    echo "${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"
}

# Edit Brewfile in chezmoi (opens the source template for editing)
brew-edit() {
    chezmoi edit ~/.my/.Brewfile
}

# Show what's installed but not in Brewfile
brew-installed-only() {
    local brewfile
    brewfile=$(_get_brewfile_path)

    echo "üì¶ Formulas installed but not in Brewfile:"
    comm -13 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort) | \
        grep -v "^$(brew deps --installed --formula | sort -u | paste -sd "|" -)$" || echo "  (none)"

    echo ""
    echo "üñ•Ô∏è  Casks installed but not in Brewfile:"
    comm -13 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort) || echo "  (none)"
}

# Show what's in Brewfile but not installed
brew-missing() {
    local brewfile
    brewfile=$(_get_brewfile_path)

    echo "üì¶ Formulas in Brewfile but not installed:"
    comm -23 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort) || echo "  (none)"

    echo ""
    echo "üñ•Ô∏è  Casks in Brewfile but not installed:"
    comm -23 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort) || echo "  (none)"
}

# Show diff between Brewfile and installed packages
brew-diff() {
    echo "=== Brewfile vs Installed Packages ==="
    echo ""
    brew-installed-only
    echo ""
    brew-missing
}

# Interactively sync Brewfile with installed packages
brew-sync() {
    local brewfile
    local temp_brewfile="/tmp/Brewfile.new"
    brewfile=$(_get_brewfile_path)

    if [[ ! -f "$brewfile" ]]; then
        echo "‚ùå Brewfile not found at $brewfile"
        return 1
    fi

    echo "üîç Analyzing installed packages..."
    echo ""

    # Generate current Brewfile
    brew bundle dump --file="$temp_brewfile" --force

    # Get lists of differences
    local new_formulas=($(comm -13 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(grep '^brew "' "$temp_brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort)))

    local new_casks=($(comm -13 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(grep '^cask "' "$temp_brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort)))

    local removed_formulas=($(comm -23 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort)))

    local removed_casks=($(comm -23 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort)))

    local changes_made=false

    # Show new formulas
    if [[ ${#new_formulas[@]} -gt 0 ]]; then
        echo "‚ûï New formulas installed (not in Brewfile):"
        for formula in "${new_formulas[@]}"; do
            echo "   - $formula"
        done
        echo ""
        read -p "Add all new formulas to Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        else
            echo "‚ÑπÔ∏è  Skipping formulas. Run 'brew-sync' again to reconsider."
        fi
    fi

    # Show new casks
    if [[ ${#new_casks[@]} -gt 0 ]]; then
        echo "‚ûï New casks installed (not in Brewfile):"
        for cask in "${new_casks[@]}"; do
            echo "   - $cask"
        done
        echo ""
        read -p "Add all new casks to Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        fi
    fi

    # Show removed items
    if [[ ${#removed_formulas[@]} -gt 0 ]] || [[ ${#removed_casks[@]} -gt 0 ]]; then
        if [[ ${#removed_formulas[@]} -gt 0 ]]; then
            echo "‚ûñ Formulas in Brewfile but not installed:"
            for formula in "${removed_formulas[@]}"; do
                echo "   - $formula"
            done
        fi
        if [[ ${#removed_casks[@]} -gt 0 ]]; then
            echo "‚ûñ Casks in Brewfile but not installed:"
            for cask in "${removed_casks[@]}"; do
                echo "   - $cask"
            done
        fi
        echo ""
        read -p "Remove uninstalled items from Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        fi
    fi

    if [[ "$changes_made" == true ]]; then
        echo ""
        echo "üìù Updating Brewfile..."
        cp "$temp_brewfile" "$brewfile"

        if command -v chezmoi &>/dev/null; then
            echo "üîÑ Syncing with chezmoi..."
            chezmoi add "$brewfile"
            echo "‚úÖ Brewfile updated and added to chezmoi!"
        else
            echo "‚úÖ Brewfile updated!"
        fi
    else
        echo "‚úÖ No changes made to Brewfile"
    fi

    rm -f "$temp_brewfile"
}

# Safe process grep with modern tool
psg() {
    if [ $# -eq 0 ]; then
        echo "Usage: psg <search_term>"
        return 1
    fi
    procs --or "${@}" 2>/dev/null || ps aux | grep -v grep | grep -i --color=auto "${@}"
}

# Safe npm clean with confirmation
unalias npm-clean 2>/dev/null || true  # Remove old alias if it exists
npm-clean() {
    echo "This will delete node_modules and reinstall. Continue? [y/N]"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        rm -rf ./node_modules && npm install
    else
        echo "Cancelled"
    fi
}

# fzf-powered directory navigation
fcd() {
    if ! command -v fd &>/dev/null || ! command -v fzf &>/dev/null || ! command -v eza &>/dev/null; then
        echo "Error: fcd requires fd, fzf, and eza to be installed"
        return 1
    fi
    local dir
    dir=$(fd --type d --hidden --follow --exclude .git | fzf --preview 'eza --tree --level=2 --icons {}') && cd "$dir" || return
}

# fzf-powered file editing
fe() {
    if ! command -v fzf &>/dev/null || ! command -v bat &>/dev/null || ! command -v code &>/dev/null; then
        echo "Error: fe requires fzf, bat, and code to be installed"
        return 1
    fi
    local files
    files=$(fzf --multi --preview 'bat --color=always --style=numbers --line-range=:500 {}') && code "$files"
}

# fzf-powered git branch switching
fbr() {
    local branch
    branch=$(git branch --all | grep -v HEAD | sed 's/remotes\/origin\///' | sort -u | fzf --preview 'git log --oneline --graph --date=short --pretty="format:%C(auto)%cd %h%d %s" {}') && git switch "$(echo "$branch" | sed 's/^[ *]*//')"
}

# fzf-powered git log viewer
fshow() {
    git log --graph --color=always \
        --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
    fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
        --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

# fzf-powered ripgrep search
frg() {
    if [ $# -eq 0 ]; then
        echo "Usage: frg <search_term>"
        return 1
    fi

    rg --color=always --line-number --no-heading --smart-case "${*:-}" |
      fzf --ansi \
          --color "hl:-1:underline,hl+:-1:underline:reverse" \
          --delimiter : \
          --preview 'bat --color=always {1} --highlight-line {2}' \
          --preview-window 'up,60%,border-bottom,+{2}+3/3,~3' \
          --bind 'enter:become(code {1}:{2})'
}

# GitHub CLI - PR viewer
ghpr() {
    if ! command -v gh &>/dev/null || ! command -v fzf &>/dev/null; then
        echo "Error: ghpr requires gh and fzf to be installed"
        return 1
    fi
    local pr_number
    pr_number=$(gh pr list | fzf --preview 'gh pr view {1}' --preview-window=right:60% | awk '{print $1}')
    if [[ -n "$pr_number" ]]; then
        gh pr view --web "$pr_number"
    fi
}

# GitHub CLI - Issue viewer
ghissue() {
    if ! command -v gh &>/dev/null || ! command -v fzf &>/dev/null; then
        echo "Error: ghissue requires gh and fzf to be installed"
        return 1
    fi
    local issue_number
    issue_number=$(gh issue list | fzf --preview 'gh issue view {1}' --preview-window=right:60% | awk '{print $1}')
    if [[ -n "$issue_number" ]]; then
        gh issue view --web "$issue_number"
    fi
}

# Export Brewfile from current installation
brew-export() {
    local brewfile
    brewfile=$(_get_brewfile_path)

    echo "üìù Generating Brewfile from current installation..."
    if ! brew bundle dump --file="$brewfile" --force; then
        echo "‚ùå Failed to generate Brewfile"
        return 1
    fi

    if command -v chezmoi &>/dev/null; then
        echo "üîÑ Syncing with chezmoi..."
        chezmoi add "$brewfile"
    fi

    echo "‚úÖ Brewfile exported to $brewfile"
}

# Detect orphaned packages (optimized with zsh arrays)
brew-orphans() {
  echo "üîç Checking for orphaned packages..."

  local -a installed leaves all_deps orphans

  # Build arrays once
  installed=(${(f)"$(brew list --formula)"})
  leaves=(${(f)"$(brew leaves)"})
  all_deps=(${(f)"$(brew deps --installed --formula)"})

  # Find packages that are neither leaves nor dependencies
  for package in $installed; do
    if [[ ! ${leaves[(ie)$package]} -le ${#leaves} ]] &&
       [[ ! ${all_deps[(ie)$package]} -le ${#all_deps} ]]; then
      orphans+=($package)
    fi
  done

  if (( ${#orphans} > 0 )); then
    echo "  üì¶ Found ${#orphans} orphaned package(s):"
    printf '  %s\n' "${orphans[@]}"
  else
    echo "  ‚ú® No orphaned packages found"
  fi
}

# Clean up brew cache
brew-cleanup() {
    echo "üßπ Cleaning up Homebrew..."
    brew cleanup --prune=all
    brew autoremove
    echo "‚úÖ Cleanup complete"
}

# =============================================================================
# Dotfiles Workflow Helpers
# =============================================================================
# Simplify common chezmoi operations to reduce knowledge required

# Pull and apply latest changes from dotfiles repo
dotfiles-sync() {
    chezmoi update
}

# Apply pending changes without pulling
dotfiles-apply() {
    chezmoi apply
}

# Show what would change
dotfiles-diff() {
    chezmoi diff
}

# Edit a dotfile in the source directory
dotfiles-edit() {
    if [ -z "$1" ]; then
        echo "Usage: dotfiles-edit <file>"
        echo "Example: dotfiles-edit ~/.zshrc"
        return 1
    fi
    chezmoi edit "$1"
}

# Add a file to dotfiles tracking
dotfiles-add() {
    if [ -z "$1" ]; then
        echo "Usage: dotfiles-add <file>"
        echo "Example: dotfiles-add ~/.myconfig"
        return 1
    fi
    chezmoi add "$1"
}

# Check status of dotfiles
dotfiles-status() {
    chezmoi status
}

# Go to dotfiles source directory
dotfiles-cd() {
    cd "$(chezmoi source-path)"
}

# Re-run setup script
dotfiles-setup() {
    "$(chezmoi source-path)/setup.sh"
}

# =============================================================================
# Modern CLI Tools (zoxide, hyperfine)
# =============================================================================

# Interactive zoxide with fzf
zi() {
  if ! command -v fzf &>/dev/null; then
    echo "‚ùå zi requires fzf"
    return 1
  fi

  local dir
  dir=$(zoxide query -l | fzf --height 40% --reverse --query "$*") && cd "$dir"
}

# Benchmark commands easily
bench() {
  if ! command -v hyperfine &>/dev/null; then
    echo "‚ùå hyperfine not installed: brew install hyperfine"
    return 1
  fi

  if [[ -z "$1" ]]; then
    echo "Usage: bench <command> [command2...]"
    echo "Example: bench 'npm run build' 'yarn build'"
    return 1
  fi

  hyperfine --warmup 3 "$@"
}

# Compare two commands
bench-compare() {
  if [[ -z "$2" ]]; then
    echo "Usage: bench-compare <command1> <command2>"
    return 1
  fi

  hyperfine --warmup 3 "$1" "$2"
}

# =============================================================================
# Git Workflow Helpers (worktrees, stash, cleanup)
# =============================================================================

# List worktrees
gwt() {
  git worktree list
}

# Add worktree with branch creation
gwta() {
  local branch="$1"
  local path="${2:-../${branch}}"

  if [[ -z "$branch" ]]; then
    echo "Usage: gwta <branch-name> [path]"
    echo "Example: gwta feature-auth"
    echo "Example: gwta feature-auth ../my-feature"
    return 1
  fi

  git worktree add -b "$branch" "$path" && cd "$path"
}

# Remove worktree interactively
gwtr() {
  if ! command -v fzf &>/dev/null; then
    echo "‚ùå gwtr requires fzf"
    return 1
  fi

  local worktree
  worktree=$(git worktree list | sed '1d' | fzf --height 40% | awk '{print $1}')
  [[ -n "$worktree" ]] && git worktree remove "$worktree"
}

# Switch to worktree (cd)
gwts() {
  if ! command -v fzf &>/dev/null; then
    echo "‚ùå gwts requires fzf"
    return 1
  fi

  local worktree
  worktree=$(git worktree list | fzf --height 40% | awk '{print $1}')
  [[ -n "$worktree" ]] && cd "$worktree"
}

# fzf-powered stash browser with preview
fstash() {
  if ! command -v fzf &>/dev/null; then
    echo "‚ùå fstash requires fzf"
    return 1
  fi

  local stash
  stash=$(git stash list | fzf \
    --height 40% \
    --preview 'git stash show -p {1}' \
    --preview-window=right:60%)

  [[ -n "$stash" ]] && git stash pop "${stash%%:*}"
}

# Interactive stash show
fstash-show() {
  if ! command -v fzf &>/dev/null; then
    echo "‚ùå fstash-show requires fzf"
    return 1
  fi

  local stash
  stash=$(git stash list | fzf \
    --height 40% \
    --preview 'git stash show -p {1}' \
    --preview-window=right:60%)

  [[ -n "$stash" ]] && git stash show -p "${stash%%:*}"
}

# Delete merged branches (interactive)
git-cleanup() {
  local branches
  branches=$(git branch --merged | grep -v '\*\|master\|main\|develop')

  if [[ -z "$branches" ]]; then
    echo "‚ú® No merged branches to clean up"
    return 0
  fi

  echo "üóëÔ∏è  Merged branches:"
  echo "$branches"
  echo ""
  read -p "Delete these branches? [y/N] " -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
    echo "$branches" | xargs git branch -d
    echo "‚úÖ Branches deleted"
  else
    echo "‚ùå Cancelled"
  fi
}

# Delete all local branches not on remote
git-prune-local() {
  git fetch -p
  local branches
  branches=$(git branch -vv | grep ': gone]' | awk '{print $1}')

  if [[ -z "$branches" ]]; then
    echo "‚ú® No orphaned branches"
    return 0
  fi

  echo "üóëÔ∏è  Branches not on remote:"
  echo "$branches"
  echo ""
  read -p "Delete these branches? [y/N] " -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then
    # Try safe delete first
    local failed_branches=""
    while IFS= read -r branch; do
      if ! git branch -d "$branch" 2>/dev/null; then
        failed_branches="$failed_branches $branch"
      fi
    done <<< "$branches"

    # Force delete unmerged branches with warning
    if [[ -n "$failed_branches" ]]; then
      echo ""
      echo "‚ö†Ô∏è  The following branches have unmerged changes:"
      echo "$failed_branches"
      echo ""
      read -p "Force delete these unmerged branches? [y/N] " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        echo "$failed_branches" | xargs git branch -D
        echo "‚úÖ All branches deleted (some forced)"
      else
        echo "‚ùå Cancelled force delete"
      fi
    else
      echo "‚úÖ Branches deleted"
    fi
  fi
}

# Quick conventional commits
gcommit() {
  local type="${1}"
  local scope="${2}"
  local message="${3:-}"

  if [[ -z "$type" ]] || [[ -z "$message" && -z "$scope" ]]; then
    echo "Usage: gcommit <type> [scope] <message>"
    echo ""
    echo "Types: feat, fix, docs, style, refactor, test, chore"
    echo "Example: gcommit feat api \"add user endpoint\""
    echo "Example: gcommit fix \"resolve memory leak\""
    return 1
  fi

  # If only 2 args, second is message not scope
  if [[ -z "$message" ]]; then
    message="$scope"
    scope=""
  fi

  local commit_msg="${type}"
  [[ -n "$scope" ]] && commit_msg="${commit_msg}(${scope})"
  commit_msg="${commit_msg}: ${message}"

  git commit -m "$commit_msg"
}

# =============================================================================
# Developer Productivity Tools
# =============================================================================

# Find what's using a port
port() {
  local port="${1}"
  if [[ -z "$port" ]]; then
    echo "Usage: port <port-number>"
    echo "Example: port 3000"
    return 1
  fi
  lsof -i ":$port"
}

# Kill process on port
killport() {
  local port="${1}"
  if [[ -z "$port" ]]; then
    echo "Usage: killport <port-number>"
    echo "Example: killport 3000"
    return 1
  fi

  local pid=$(lsof -ti ":$port")
  if [[ -z "$pid" ]]; then
    echo "‚ùå No process found on port $port"
    return 1
  fi

  echo "üõë Stopping process $pid on port $port (SIGTERM)..."
  kill -15 "$pid" 2>/dev/null

  # Wait up to 3 seconds for graceful shutdown
  local count=0
  while kill -0 "$pid" 2>/dev/null && [[ $count -lt 6 ]]; do
    sleep 0.5
    count=$((count + 1))
  done

  # Force kill if still running
  if kill -0 "$pid" 2>/dev/null; then
    echo "‚ö†Ô∏è  Process didn't stop gracefully, force killing (SIGKILL)..."
    kill -9 "$pid" 2>/dev/null
  fi

  echo "‚úÖ Process stopped"
}

# List all listening ports
ports() {
  echo "üì° Listening ports:"
  lsof -iTCP -sTCP:LISTEN -n -P
}

# List available .env files
envs() {
  echo "Available environment files:"
  ls -1 .env* 2>/dev/null | nl
}

# Switch .env file
envswitch() {
  local env_file=".env.${1}"

  if [[ -z "$1" ]]; then
    echo "Usage: envswitch <environment>"
    echo "Example: envswitch dev, envswitch prod"
    envs
    return 1
  fi

  if [[ ! -f "$env_file" ]]; then
    echo "‚ùå $env_file not found"
    envs
    return 1
  fi

  # Backup existing .env if it exists
  if [[ -f .env ]]; then
    local timestamp=$(date +%Y%m%d_%H%M%S)
    cp .env ".env.backup.$timestamp"
    echo "üíæ Backed up current .env to .env.backup.$timestamp"

    # Keep only last 3 backups
    local backup_count=$(ls -1 .env.backup.* 2>/dev/null | wc -l | tr -d ' ')
    if [[ $backup_count -gt 3 ]]; then
      ls -1t .env.backup.* | tail -n +4 | xargs rm -f
      echo "üßπ Cleaned up old backups (kept last 3)"
    fi
  fi

  cp "$env_file" .env
  echo "‚úÖ Switched to $env_file"
}

# Create .env from template
envnew() {
  local env_name="${1}"

  if [[ -z "$env_name" ]]; then
    echo "Usage: envnew <environment>"
    echo "Example: envnew staging"
    return 1
  fi

  local env_file=".env.${env_name}"

  if [[ -f "$env_file" ]]; then
    echo "‚ùå $env_file already exists"
    return 1
  fi

  if [[ -f ".env.template" ]]; then
    cp .env.template "$env_file"
    echo "‚úÖ Created $env_file from template"
  else
    touch "$env_file"
    echo "‚úÖ Created empty $env_file"
  fi

  ${EDITOR:-code} "$env_file"
}

# Copy with confirmation
# Copy to clipboard (renamed from 'copy' to avoid conflict with cp plugin)
clip() {
  if [[ -t 0 ]]; then
    echo -n "$*" | pbcopy && echo "‚úÖ Copied to clipboard"
  else
    pbcopy && echo "‚úÖ Copied to clipboard"
  fi
}

# Paste
paste() {
  pbpaste
}

# Copy file content
copyfile() {
  if [[ -z "$1" ]] || [[ ! -f "$1" ]]; then
    echo "Usage: copyfile <file>"
    return 1
  fi
  cat "$1" | pbcopy
  echo "‚úÖ Copied $1 to clipboard"
}

# Copy current directory path
copypath() {
  pwd | tr -d '\n' | pbcopy
  echo "‚úÖ Copied: $(pwd)"
}
