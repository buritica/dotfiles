# `e` with no arguments opens the current directory in VSCode, otherwise
# opens the given location
function e() {
	if [ $# -eq 0 ]; then
		code .;
	else
		code "$@";
	fi;
}

# `s` with no arguments cds into ~/src directory, otherwise opens the given subdir
function s() {
	if [ $# -eq 0 ]; then
		cd ~/src;
	else
		cd ~/src/"$@";
	fi;
}

# `my` with no arguments cds into ~/.my directory, otherwise opens the given subdir
function my() {
	if [ $# -eq 0 ]; then
		cd ~/.my;
	else
		cd ~/.my/"$@";
	fi;
}

# `dr` with no arguments cds into iCloud Drive  directory, otherwise opens the given subdir
function dr() {
	if [ $# -eq 0 ]; then
		cd ~/Library/Mobile\ Documents/com~apple~CloudDocs;
	else
		cd ~/Library/Mobile\ Documents/com~apple~CloudDocs/"$@";
	fi;
}

# empty commit as todo
todo() {
  git commit --allow-empty -m "TODO: $*"
}

# turn movie into gif
# thanx SlexAxton https://gist.github.com/SlexAxton/4989674
gifify() {
  if [[ -n "$1" ]]; then
    if [[ $2 == '--good' ]]; then
      ffmpeg -i $1 -r 10 -vcodec png out-static-%05d.png
      time convert -verbose +dither -layers Optimize -resize 600x600\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > $1.gif
      rm out-static*.png
    else
      ffmpeg -i $1 -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > $1.gif
    fi
  else
    echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# Create a new directory and enter it
function mkd() {
  mkdir -p "$@" && cd "$_";
}

# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')";
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh;
  else
    local arg=-sh;
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@";
  else
    du $arg .[^.]* *;
  fi;
}

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
  function diff() {
    git diff --no-index --color-words "$@";
  }
fi;

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}";
  sleep 1 && open "http://localhost:${port}/" &
  # Use Python 3's http.server module
  python3 -m http.server "$port";
}

# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
  if [ -t 0 ]; then # argument
    python3 -m json.tool <<< "$*" | pygmentize -l javascript;
  else # pipe
    python3 -m json.tool | pygmentize -l javascript;
  fi;
}

# `o` with no arguments opens the current directory, otherwise opens the given
# location
function o() {
  if [ $# -eq 0 ]; then
    open .;
  else
    open "$@";
  fi;
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}


# Safer alternative to fixit - amend and push without force
# Uses --force-with-lease which is safer than --force
fixup() {
    git add . && git commit --amend --no-edit && git push --force-with-lease
}

# contains(string, substring)
#
# Returns 0 if the specified string contains the specified substring,
# otherwise returns 1.
contains() {
    string="$1"
    substring="$2"
    if test "${string#*$substring}" != "$string"
    then
        return 0    # $substring is in $string
    else
        return 1    # $substring is not in $string
    fi
}

# Show what's installed but not in Brewfile
brew-installed-only() {
    local brewfile="${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"

    # If in chezmoi source directory, use the template file
    if [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        brewfile="dot_my/dot_Brewfile.tmpl"
    fi

    echo "📦 Formulas installed but not in Brewfile:"
    comm -13 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort) | \
        grep -v "^$(brew deps --installed --formula | sort -u | paste -sd "|" -)$" || echo "  (none)"

    echo ""
    echo "🖥️  Casks installed but not in Brewfile:"
    comm -13 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort) || echo "  (none)"
}

# Show what's in Brewfile but not installed
brew-missing() {
    local brewfile="${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"

    # If in chezmoi source directory, use the template file
    if [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        brewfile="dot_my/dot_Brewfile.tmpl"
    fi

    echo "📦 Formulas in Brewfile but not installed:"
    comm -23 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort) || echo "  (none)"

    echo ""
    echo "🖥️  Casks in Brewfile but not installed:"
    comm -23 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort) || echo "  (none)"
}

# Show diff between Brewfile and installed packages
brew-diff() {
    echo "=== Brewfile vs Installed Packages ==="
    echo ""
    brew-installed-only
    echo ""
    brew-missing
}

# Interactively sync Brewfile with installed packages
brew-sync() {
    local brewfile="${HOMEBREW_BUNDLE_FILE:-$HOME/.my/.Brewfile}"
    local temp_brewfile="/tmp/Brewfile.new"

    # If in chezmoi source directory, use the template file
    if [[ -f "dot_my/dot_Brewfile.tmpl" ]]; then
        brewfile="dot_my/dot_Brewfile.tmpl"
    fi

    if [[ ! -f "$brewfile" ]]; then
        echo "❌ Brewfile not found at $brewfile"
        return 1
    fi

    echo "🔍 Analyzing installed packages..."
    echo ""

    # Generate current Brewfile
    brew bundle dump --file="$temp_brewfile" --force

    # Get lists of differences
    local new_formulas=($(comm -13 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(grep '^brew "' "$temp_brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort)))

    local new_casks=($(comm -13 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(grep '^cask "' "$temp_brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort)))

    local removed_formulas=($(comm -23 \
        <(grep '^brew "' "$brewfile" | sed 's/brew "\([^"]*\)".*/\1/' | sort) \
        <(brew list --formula | sort)))

    local removed_casks=($(comm -23 \
        <(grep '^cask "' "$brewfile" | sed 's/cask "\([^"]*\)".*/\1/' | sort) \
        <(brew list --cask | sort)))

    local changes_made=false

    # Show new formulas
    if [[ ${#new_formulas[@]} -gt 0 ]]; then
        echo "➕ New formulas installed (not in Brewfile):"
        for formula in "${new_formulas[@]}"; do
            echo "   - $formula"
        done
        echo ""
        read -p "Add all new formulas to Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        else
            echo "ℹ️  Skipping formulas. Run 'brew-sync' again to reconsider."
        fi
    fi

    # Show new casks
    if [[ ${#new_casks[@]} -gt 0 ]]; then
        echo "➕ New casks installed (not in Brewfile):"
        for cask in "${new_casks[@]}"; do
            echo "   - $cask"
        done
        echo ""
        read -p "Add all new casks to Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        fi
    fi

    # Show removed items
    if [[ ${#removed_formulas[@]} -gt 0 ]] || [[ ${#removed_casks[@]} -gt 0 ]]; then
        if [[ ${#removed_formulas[@]} -gt 0 ]]; then
            echo "➖ Formulas in Brewfile but not installed:"
            for formula in "${removed_formulas[@]}"; do
                echo "   - $formula"
            done
        fi
        if [[ ${#removed_casks[@]} -gt 0 ]]; then
            echo "➖ Casks in Brewfile but not installed:"
            for cask in "${removed_casks[@]}"; do
                echo "   - $cask"
            done
        fi
        echo ""
        read -p "Remove uninstalled items from Brewfile? [y/N] " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            changes_made=true
        fi
    fi

    if [[ "$changes_made" == true ]]; then
        echo ""
        echo "📝 Updating Brewfile..."
        cp "$temp_brewfile" "$brewfile"

        if command -v chezmoi &>/dev/null; then
            echo "🔄 Syncing with chezmoi..."
            chezmoi add "$brewfile"
            echo "✅ Brewfile updated and added to chezmoi!"
        else
            echo "✅ Brewfile updated!"
        fi
    else
        echo "✅ No changes made to Brewfile"
    fi

    rm -f "$temp_brewfile"
}
